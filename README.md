# Java 并发编程
## 基础篇
#### 进程与线程基本概念
进程和线程的区别:  
- 进程是一个独立的运行环境, 而线程是在进程中执行的一个任务. 它们两个本质的区别是是否单独战友内存地址空间及其他系统资源(比如 I/O)
>- 进程单独占有一定的内存地址空间, 所以进程间存在内存隔离, 数据是分开的, 数据共享复杂但是同步简单, 各个进程之间互不干扰; 而线程共享所属进程占有的内存地址空间和资源, 数据共享简单, 但是同步复杂.
>- 进程单独占有一定的内存地址口空间, 一个进程出现问题不会影响其他进程, 不影响主程序的稳定性, 可靠性高; 一个线程崩溃可能影响这个程序的稳定性, 可靠性低.
>- 进程单独占有一定的内存地址空间, 进程的创建和销毁不仅需要保存寄存器和栈信息, 还需要资源的分配回收和页调度, 开销较大; 线程值需要保存寄存器和栈信息, 开销较小.
- 进程是操作系统进行资源分配的基本单位, 而线程是操作系统进行调度的基本单位, 即CPU分配时间的单位. 

#### Java多线程入门类和接口
- `Thread`类和`Runnable`接口
>- 继承`Thread`类, 并重写`run`方法
>- 实现`Runnable`接口的`run`方法
#### 线程组和线程优先级
#### Java线程的状态以及主要转化方法
#### Java线程间的通信

## 原理篇
#### Java内存模型基础知识
##### 1. 并发编程的两个关键问题
1. 线程间如何通信? 即: 线程之间以何种机制来交换信息
2. 线程间如何同步? 即: 线程以何种机制来控制不同线程间操作发生的相对顺序
##### 2. Java 内存模型的抽象结构
- 运行时内存的划分  
![java内存模型](./doc/picture/Java运行时数据区.png)  
- 堆是共享的, 为什么在堆中会有内存不可见问题?  
计算机为了高效, 往往会在告诉缓存区中缓存共享变量, 因为CPU访问缓存区比访问内存要快得多.
> 线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本。本地内存是Java内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等.  

Java线程之间的通信由Java内存模型(JMM)控制, 从抽象的角度说, JMM定义了线程和主内存之间的抽象关系. JMM的抽象示意图:  
![JMM抽象示意图](doc/picture/JMM抽象示意图.jpg)  
1. 所有的共享变量都存在主内存中
2. 每个线程都保存了一份该线程使用到的共享变量的副本.
3. 如果线程A与线程B之间要通信的话, 必须经过2个步骤: ①线程A将本地内存A中更新过的共享变量刷新到主内存中去. ②线程B到主内存中去读取线程A之前已经更新过的共享变量.  

所以线程A无法直接访问线程B的工作内存, 线程间通信必须经过主内存.  
根据JMM的规定, 线程对共享变量的所有操作都必须在自己的本地内存中进行, 不能直接从主内存中读取.  
那么怎么知道这个共享变量被其他线程更新了呢? -> JMM通过控制主内存与每个线程的本地内存之间的交互, 来提供可见性的保证.
> Java中的volatile关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized关键字不仅保证可见性，同时也保证了原子性（互斥性）。在更底层，JMM通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员的方便理解，提出了happens-before，它更加的简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。这里涉及到的所有内容后面都会有专门的章节介绍
#### 重排序与happens-before
#### volatile
#### synchronized 与 锁
#### CAS与原子操作
#### AQS

## JDK工具篇